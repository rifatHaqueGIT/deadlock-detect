// =============================================================================
//                        !!! DO NOT EDIT THIS FILE !!!
// =============================================================================

#include "common.h"
#include "deadlock_detector.h"
#include <algorithm>
#include <cassert>
#include <cstdlib>
#include <iomanip>
#include <iostream>
#include <memory>
#include <numeric>
#include <set>
#include <vector>

using VS = std::vector<std::string>;

static bool vscmp(VS v1, VS v2)
{
    std::sort(v1.begin(), v1.end());
    std::sort(v2.begin(), v2.end());
    return v1 == v2;
}

static VS splitc(const std::string & s, char split_char = '\n')
{
    VS res;
    std::stringstream iss(s);

    while (iss.good()) {
        std::string line;
        getline(iss, line, split_char);
        res.push_back(line);
    }
    // std::cout << "['" << join(res, "','") << "']\n";
    return res;
};

static void test(const std::string & test_name, const VS & lines, int lineno, const VS & cycle)
{
    std::cout << "- running " << std::setw(20) << std::left << test_name << " ..." << std::flush;

    int ret_edge_ind = 123;
    Timer timer;
    std::vector<std::string> ret_cycle;
    detect_deadlock(lines, ret_edge_ind, ret_cycle);
    std::cout << "  - finished in " << std::fixed << std::setprecision(4) << timer.elapsed() << "s";
    if (ret_edge_ind == lineno && vscmp(cycle, ret_cycle)) {
        std::cout << " PASSED\n";
        return;
    }

    int mw = 8;
    for (const auto & line : lines)
        mw = std::max(mw, int(line.size()));
    std::cout << " FAILED.\n"
              << "  - input:\n";
    std::cout << "    +" + std::string(mw + 2, '-') + "+\n";
    for (const auto & line : lines)
        std::cout << "    | " + line + std::string(mw - line.size(), ' ') + " |\n";

    std::cout << "    +" + std::string(mw + 2, '-') + "+\n";
    std::cout << "  - expected index  : " << std::setw(5) << std::left << lineno
              << " cycle: " << join(cycle, ",") << "\n"
              << "  - calculated index: " << std::setw(5) << std::left << ret_edge_ind
              << " cycle: " << join(ret_cycle, ",") << "\n";
}

static int run_tests()
{
    std::cout << "Running built-in mini-tests\n";
    std::stringstream iss;
    test("empty test", {}, -1, {});
    test("one edge test", { "1 -> 1" }, -1, {});
    test("tiny deadlock", splitc("p1 -> m1|p1 <- m2|p2 -> m2|p2 <- m1", '|'), 3, { "p1", "p2" });
    test(
        "tiny deadlock2",
        splitc("p1 -> m1|p1 <- m2|p2 -> m2|p2 <- m1|a -> b", '|'),
        3,
        { "p1", "p2" });
    test(
        "tiny deadlock2",
        splitc("p1 -> m1|p1 <- m2|p2 -> m2|a -> b|p2 <- m1", '|'),
        4,
        { "p1", "p2" });
    test(
        "tiny deadlock3",
        splitc("x <- y|p1 -> m1|p1 <- m2|p2 -> m2|a -> b|p2 <- m1", '|'),
        5,
        { "p1", "p2" });
    test(
        "tiny deadlock4",
        splitc("x -> m1|p1 -> m1|p1 <- m2|p2 -> m2|y -> m1|p2 <- m1", '|'),
        5,
        splitc("p1,p2,x,y", ','));
    test(
        "test1.txt",
        splitc("  2    <-   fork1    \n"
               " plato  ->     fork1 \n"
               "plato   ->  2        \n"
               "socrates -> fork1    \n"
               "socrates <- 2        "),
        -1,
        {});

    return 0;
}
static int run_graph()
{
    std::cout << "Reading in lines from stdin...\n";
    VS all_lines;
    int line_no = 0;
    while (1) {
        // read in the next line and quit loop on EOF
        auto line = stdin_readline();
        if (line.size() == 0)
            break;
        line_no++;

        // get rid of trailing \n
        if (line.size() && line.back() == '\n')
            line.pop_back();

        // parse input line, skip empty lines
        auto toks = split(line);
        if (toks.size() == 0)
            continue;

        // validate line
        if (toks.size() != 3 || (toks[1] != "->" && toks[1] != "<-") || !is_alnum(toks[0])
            || !is_alnum(toks[2])) {
            std::cout << "Syntax error on line " << line_no << ": " << line << "\n";
            exit(-1);
        }

        all_lines.push_back(line);
    }

    std::cout << "Running detect_deadlock()...\n";
    VS cycle { "000", "1", "222" };
    int edge_index = -999;
    Timer timer;
    detect_deadlock(all_lines, edge_index, cycle);
    std::cout << "\n"
              << "edge_index : " << edge_index << "\n"
              << "cycle      : [" << join(cycle, ",") << "]\n"
              << "real time  : " << std::fixed << std::setprecision(4) << timer.elapsed()
              << "s\n\n";
    // check for duplicates in cycle
    std::set<std::string> pnames1;
    for (auto const & pname : cycle)
        pnames1.insert(pname);
    if (pnames1.size() != cycle.size())
        std::cout << "Warning: duplicate entries in cycle.\n";
    std::set<std::string> pnames2;
    for (auto const & line : all_lines)
        pnames2.insert(split(line)[0]);
    std::vector<std::string> unknowns;
    for (auto const & pname : pnames1)
        if (pnames2.find(pname) == pnames2.end())
            unknowns.push_back(pname);
    if (unknowns.size() > 0)
        std::cout << "Warning: unknown processes in cycle: [" << join(unknowns, ",") << "]\n";
    return 0;
}
static int usage(const std::string & pname)
{
    std::cout << "Usage:\n"
              << "    " << pname << " [test]\n"
              << "        - to run built-in tests\n"
              << "    " << pname << " < input\n"
              << "        - to process input from stdin\n";
    return -1;
}

static int cppmain(const VS & args)
{
    if (args.size() == 2 && args[1] == "test")
        return run_tests();
    else if (args.size() == 1)
        return run_graph();
    else
        return usage(args[0]);
}

int main(int argc, char ** argv)
{
    try {
        return cppmain({ argv + 0, argv + argc });
    } catch (...) {
        std::cerr << "Unhandled exception occurred."
                  << "\n";
        return -1;
    }
}
